@title 句柄技术文档
@group handles

句柄 （handles） 技术概述。

概述
========

Phabricator 中的大多数对象都有全局唯一标识符 PHID，
看起来像 `PHID-USER-2zw4hwdt4i5b5ypikv6x`。 
如果您知道某个对象的 PHID，您可以为该对象加载一个 **句柄**，以获取有关该对象的更多信息。

句柄是对象的轻量级引用，它提供了所有对象（例如它们的类型，图标，名称，会标，URI，以及它们是打开还是关闭）
通用的一些基本信息。 应用程序加载和使用句柄不需要知道关于其他类型的对象的任何东西。 
有统一的机制可用于加载和处理句柄，它适用于任意应用程序中的任意类型的对象。


加载句柄
===============

要加载句柄，通常在视图中调用 `loadHandles(...)`：

  $handles = $viewer->loadHandles($phids);

这返回一个 @{class:PhabricatorHandleList} 对象。 
此对象的行为类似于数组，您可以通过使用其 PHID 作为索引访问句柄对象：

  $handle = $handles[$phid];

即使 PHID 无效或它识别的对象受限或破坏，句柄也会加载。 
在这些情况下，句柄将准确地表示相关对象的状态。 
这意味着你通常不需要检查是否加载了句柄。


渲染句柄
=================

加载句柄后，通常会调用 `renderHandle($phid)` 来渲染对象的链接：

  $view = $handles->renderHandle($phid);

这将返回 @{class:PHUIHandleView} 对象。 
此类有一些方法可以调整对句柄的渲染。

可以使用 `renderList()` 渲染句柄列表。

  $list_view = $handles->renderList();

这将返回 @{class:PHUIHandleListView} 对象。
此类也有一些方法可以调整对句柄列表的渲染。

这些操作的方法也可以在视图对象本身上也可以使用：

  $view = $viewer->renderHandle($phid);
  $list_view = $viewer->renderHandleList($phids);

当你只需要渲染一个句柄一次，这些方法使得更容易。


Fetch Semantics
===============

当您通过视图加载和渲染句柄时，实际的数据获取是及时（just-in-time）发生的。 
具体地，所有需要的 PHID 将加入队列，当//需要//显示时， 手柄将批量加载。


这意味着，与大多数其他类型的数据提取不同，单个获取句柄是可以的，
因为它们不会真的//单次//获取。这段代码是正确和可取的：


  $list->addProperty(pht('Pilot'), $viewer->renderHandle($pilot_phid));
  $list->addProperty(pht('Copilot'), $viewer->renderHandle($copilot_phid));

如果你需要渲染大量的句柄（例如，在结果列表视图中有100个句柄），
使用 @{class:PhabricatorHandleList} 渲染它们，效率有//轻微//提升：

  $handles = $viewer->loadHandles($phids);
  foreach ($items as $item) {
    // ...
    $view = $handles->renderHandle($item->getPHID());
    // ...
  }

这削减了一点点内部记帐开销。 这不会更改数据提取的基础语义。

句柄特别适合使用这种即时获取模式，因为它们无处不在，
并且代码基本上不依赖句柄，因此在最终页面呈现之前，
它们很少需要具体化。 大多数其他类型的数据不具有相同类型的应用程序级语义。
这通常使得其他对象不太适合即时获取。
